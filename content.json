{"pages":[],"posts":[{"title":"ECMAScript 6 - Promise对象","text":"# Promise 含义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。 它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 参考链接http://es6.ruanyifeng.com/#docs/promise # 基本用法ES6 规定，Promise对象是一个构造函数，用来生成 Promise 实例。 下面代码创造了一个 Promise 实例。 123456789const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); }}); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。 reject函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。 12345promise.then(function(value) { // success}, function(error) { // failure}); then方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。 图示： # 例子 效果图 ： index.html 文件：https://jsbin.com/gamewasari/edit?html,console,output # 结语以上是我总结的一个简单的异步执行回调方法，有问题可以留言。(∩_∩)","link":"/ECMAScript-6-Promise/"},{"title":"（一）教你使用Hexo-Github-Pages搭建个人独立博客","text":"# 前言若您在安装过程中遇到问题或无法找到解决方式，可以在评论区提问，我会尽力帮助您解决问题！ # 推荐理由1. 免费Github 提供 GitHub Pages 服务是免费的，有 300MB 的空间。 2. 开源由于 github 开源的原因，有很多人参与其中，自然技术支持很好。 3. 便捷博客完全托管在 github 上，基本上不需要花时间去管理，博客使用 Markdown 语法，上手很容易。 # 需要了解的内容（能掌握更好） html+css+javascript git 基本语法 markdown 语法 nodejs 目前，在 github 上搭建博客系统使用最多就是 Hexo 和 Jekyll。Hexo 是基于 Nodejs 开发的，Jekyll 是基于 Ruby 开发的。 说明：文中出现的命令，Windows 用户注意，命令前面有 $ 的表示在 Git Bash 中执行，没有的在 CMD 命令窗口执行。Linux 和 MAC 系统在终端下不区分。 # 系统环境配置安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Git Node.js # 安装 Git 客户端 Git 1.下载 Git 客户端 2.安装 Git 客户端Windows 用户直接 Next 就可以了。Mac 和 Linxu 系统的用户可通过命令方式安装，这里不详细介绍了。 # 安装 Node.js Node.js 检查 node.js 是否安装: 12$ node -vv8.6.0 (Node版本号, 已安装Node.js) # 初探 Hexo 以下操作是在blog文件夹中 1.安装 Hexo1$ npm install hexo-cli -g 说明： hexo 全局安装一次就够了，后面可以直接使用 hexo 相关的操作。 # 创建本地博客文件夹1.初始化 hexo 文件夹名称：blog（可自定义）新建一个网站。如果没有设置 blog 文件夹 ，Hexo 默认在目前的路径新建文件夹 blog，并且建立网站。 1$ hexo init blog 2.新建一篇文章 文章标题：title（可自定义） 1$ hexo new title 如果标题包含空格的话，请使用引号括起来。 1$ hexo new &quot;First Title&quot; 3.启动 Hexo1$ hexo server 启动之后，打开浏览器，在地址栏输入：http://localhost:4000 ，你就会看到 Hexo 的示例页面。 注：此时可以初始化 git 本地仓库了，或者是等本地博客搭建好之后也可以。 # 结语 第一步，我们搭建了本地的 Hexo 博客，并通过 http://localhost:4000 访问了它。手把手教你使用 Hexo-Github-Pages 搭建个人独立博客（一）第二步，我们要将博客上传到 GitHub，并通过 Github-Pages 配置在网页上提供访问。详情请看文章：手把手教你使用 Hexo-Github-Pages 搭建个人独立博客（二）第三步，部署 Hexo，将 hexo 生成的静态内容部署到配置的仓库中，详情请看文章：手把手教你使用 Hexo-Github-Pages 搭建个人独立博客（三）","link":"/create-the-blog-1/"},{"title":"（二）教你使用Hexo-Github-Pages搭建个人独立博客","text":"# 注册 GitHub 老手和已注册过的用户略过，直接进行下一步 1.打开 GitHub 官网GitHub 官网:https://github.com/ 2.填写注册信息进行注册操作没有登录的用户打开网站首页就会显示注册的操作（如下图所示），或者是点击Sign up按钮进入注册详情页。 3.注册信息填写好注册信息，点击Sign up for GitHub(注册)按钮，接下来是选择协议部分。根据自己的情况选择相关的协议，一般人选的都是免费的那一项。 # 登录 Github在 github 首页点击 Sign in 按钮进入登录页面。填写用户名或邮箱和密码，点击Sign in按钮登录。 # 配置 SSH 老手和已注册过的用户略过 #windows 系统（mac 系统直接走第 4 步）1.下载Git BashGit Bash官网地址：https://git-scm.com/ 2.打开Git Bash终端在桌面右键，会出现 Git Bash here 的选项，点击即可。 3.设置user name和email12$ git config --global user.name &quot;你的GitHub用户名&quot;$ git config --global user.email &quot;你的GitHub注册邮箱&quot; 4.生成ssh密钥1$ ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 一般情况下是不需要密码的，所以，接下来直接回车就好。 此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的 ssh 密钥文件id_rsa和id_rsa.pub。注：id_rsa文件是私钥，要妥善保管，id_rsa.pub是公钥文件。 5.添加公钥到 github 点击用户头像，然后点击显示的Settings(设置)选项。 在用户设置栏，点击SSH and GPG keys选项，然后点击New SSH key(新建 SSH)按钮。 将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加 SSH)按钮。 6.测试 SSH1$ ssh -T git@github.com 接下来会出来下面的确认信息 The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 17:24:ac:a5:76:28:24:36:62:1b:36:4d:eb:df:a6:45. Are you sure you want to continue connecting (yes/no)?输入 yes ，然后回车。 显示如下信息则配置 SSH 成功！其中的CC-cat是用户名。 Hi CC-cat! You&apos;ve successfully authenticated, but GitHub does not provide shell access. # 创建 GitHub 仓库1.点击创建仓库点击在登录的用户图像左边的+号和下三角符号按钮。 2.填写创建仓库信息仓库名称必须是用户名.github.io（具体看 GitHubPages 创建规则），比如我的用户名是CCcat，就是CCcat.github.io。 3.填写相关信息填写好相关信息，点击Create repository（创建仓库）按钮。 # 上传本地项目到 GitHub 以下两种方法二选一 1.通过终端命令行上传（具体方法请自行Google）2.通过 Sourcetree 软件辅助上传 # 创建 GitHub Pages找到GitHub远端博客项目下，Settings选项下往下找，有一个 GitHub Pages ，按照截图内容配置。 配置完正常显示如下 按照截图配置成功后，此时就可以初始化 git 本地仓库，部署 Hexo 了。部署 Hexo，请看 手把手教你使用 Hexo-Github-Pages 搭建个人独立博客（三） # 结语 第一步，我们搭建了本地的 Hexo 博客，并通过 http://localhost:4000 访问了它。手把手教你使用 Hexo-Github-Pages 搭建个人独立博客（一）第二步，我们要将博客上传到 GitHub，并通过 Github-Pages 配置在网页上提供访问。详情请看文章：手把手教你使用 Hexo-Github-Pages 搭建个人独立博客（二）第三步，部署 Hexo，将 hexo 生成的静态内容部署到配置的仓库中，详情请看文章：手把手教你使用 Hexo-Github-Pages 搭建个人独立博客（三）","link":"/create-the-blog-2/"},{"title":"（三）教你使用Hexo-Github-Pages搭建个人独立博客","text":"# 再探 Hexo 介绍 hexo 常用操作命令，以下操作是在 blog 文件夹中: 1.新建文章:1$ hexo new &quot;My New Post&quot; 此时在source_posts文件夹中便会多出一个文档 title.md。如果要删除，直接在此文件夹下删除对应的文件即可。 2.生成静态页面1$ hexo generate 生成的静态内容在public文件夹内。 3.清除生成内容1$ hexo clean 4.部署 Hexo1$ hexo deploy 该操作会将 hexo 生成的静态内容部署到配置的仓库中 # 部署 Hexo1.编辑配置文件，关联远程仓库 在编辑器中打开 Hexo 配置文件_config.yml，找到下面内容: 1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: 添加 github 仓库信息: 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:CC-cat/CC-cat.github.io.git #github仓库地址 branch: master # github分支 message: 注意： &gt; type、repo.. 的前面有 2 个空格，: 号后面有 1 个空格。: 号后面的空格不可缺少，否则会报错！ 2.安装 git 插件1npm install hexo-deployer-git --save 如果没有安装 git 插件，会有错误提示，安装后重新部署就可以了。 3.部署1hexo deploy 如果没有意外，部署就成功了，可以打开 http://&lt;用户名&gt;.github.io 查看。或者在 GitHub 博客代码页，找到 Settings 在 GitHub Pages 处查看。 # Hexo 命令缩写1234hexo n 'title' == hexo new 'title' # 写文章hexo g == hexo generate # 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹hexo s == hexo server # 启动本地web服务，用于博客的预览默认端口4000，'ctrl + c'关闭server）hexo d == hexo deploy # 部署博客到远端（比如github, heroku等平台） 12$ hexo new &quot;postName&quot; # 新建文章$ hexo new page &quot;pageName&quot; # 新建页面 # 推送到远程使用hexo clean hexo g hexo d 将本地博客推送到远程，即可看到更新后的博客文章。 123$ hexo clean$ hexo g$ hexo d # Hexo 命令组合12$ hexo clean &amp;&amp; hexo s -g # 就是清除、生成、启动$ hexo clean &amp;&amp; hexo d -g # 就是清除、生成、部署 目前我安装所用的本地环境如下：(可以通过hexo -v查看) 123456789101112131415hexo-cli: 1.1.0os: Darwin 18.2.0 darwin x64http_parser: 2.7.0node: 8.6.0v8: 6.0.287.53uv: 1.14.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2licu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b # 结语 以上，就完成了个人博客的基础搭建。希望大家都能有个属于自己的一片天地！(∩_∩)","link":"/create-the-blog-3/"},{"title":"Hexo 更换主题风格 之 hexo-theme-snippet","text":"Hexo 给我们提供了很多的主题供我们选择，你可以在 更多主题 里选择一款你喜欢的。 # 主题介绍Snippet 简洁而不简单，也许是一款你寻找已久的 hexo 主题。 主题名称：hexo-theme-snippet 主题简称：Snippet 主题特点： 原生 JavaScript 实现 样式支持 CSS 预处理器 Less，方便主题自定义 文章过期提醒功能 文章阅读进度条 网站公告功能 首页图片懒加载 首页文章缩略图自动检索文章内图片，支持自动随机图片 主题支持响应式 支持 3D 云标签 支持文章推送和文章打赏 站内本地搜索和谷歌搜索 支持多个第三方评论系统 支持网站统计和不蒜子访客统计 移动端的简洁设计 支持代码高亮并支持自定义高亮样式 支持 Shell 脚本一键使用 Travis CI 自动化部署博客 # 步骤1.copy 主题打开主题链接 https://github.com/shenliyang/hexo-theme-snippet，并复制主题 Git 地址。 2.开始下载主题12345$ cd 'to/your/path' #项目放置的路径$ hexo clean #清除$ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/hexo-theme-snippet #复制Git地址，放在themes文件夹下 主题可能会不定时优化和更新，更新主题代码: 123$ cd themes/hexo-theme-snippet$ git pull #主题拉取更新 3.修改主题名称修改根目录下的 _config.yml 文件，修改主题名称。 1theme: hexo-theme-snippet #主题名称 要与 主题文件夹名称一致 图示： 4.添加主题插件这个根据不同主题的安装要求下载！ 123$ cd ../../ #回到你的博客文件根目录$ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S 5.运行博客1$ hexo clean &amp;&amp; hexo s -g # 就是清除、生成、启动 启动之后，打开浏览器，在地址栏输入：http://localhost:4000 ，你就会看到 Hexo 的示例页面。 图示： 6.发布博客1$ hexo clean &amp;&amp; hexo d -g # 就是清除、生成、部署 # 结语到这里，文章就结束啦！(∩_∩)","link":"/create-the-blog-5/"},{"title":"（四）教你任意更换 Hexo 主题风格","text":"# 前言创建 Hexo 主题非常容易，您只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改_config.yml 内的 theme 设定，即可切换主题。 这篇文章，简单的讲解了更换 Hexo 主题风格的操作。 想换任意 Hexo 主题都可以！ 这篇文章示例主题是：clover # 步骤1.主题风格打开链接 https://hexo.io/themes/ ，预览、挑选自己喜欢的主题风格。 复制自己喜欢的主题的 Git 地址： 查看主题说明：(README.md) 2.开始下载主题12345$ cd 'to/your/path' #项目放置的路径$ hexo clean #清除$ git clone https://github.com/esappear/hexo-theme-clover themes/clover #复制Git地址，放在themes文件夹下 主题可能会不定时优化和更新，更新主题代码: 123$ cd themes/clover$ git pull #主题拉取更新 图示： 3.修改根目录下的 _config.yml 文件，修改主题名称。 1theme: clover #主题名称 要与 主题文件夹名称一致 4.添加主题插件（这个根据不同主题的安装要求下载） 123$ cd ../../ #回到你的博客文件根目录$ npm install hexo-renderer-sass --save 5.运行博客 1$ hexo clean &amp;&amp; hexo s -g # 就是清除、生成、启动 启动之后，打开浏览器，在地址栏输入：http://localhost:4000 ，你就会看到 Hexo 的示例页面。 图示： 6.发布博客 1$ hexo clean &amp;&amp; hexo d -g # 就是清除、生成、部署 # Error1.执行deploy时报错1ERROR Deployer not found: git 解决方法： 1$ npm install hexo-cli -g 然后再提交就可以了！ 2.执行 deploy 时报错 11Error: Permission denied (publickey) 解决方法： ①.这种情况就是要在 github 添加 publickey, 允许 SSH 方式上传代码。步骤如下：②.官方链接地址 解决办法。 方法 ①： 生成 key（xxxx 换成你自己 github 用户名） 1$ ssh-keygen -t rsa -C “xxxxxxxxx” 打印 key（第一步生成时会在控制台打印出地址） 1$ cat /Users/xuneng/.ssh/id_rsa.pub 进入到该github项目的设置，把打印出的key的所有字符串，拷贝到Deploy keys中保存即可。（勾选允许可写操作） 测试 github SSH 连通性 1$ ssh -T git@github.com 显示如下信息则配置 SSH 成功！其中的 CC-cat 是用户名。 Hi CC-cat! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 然后再提交就可以了！ 3.执行 deploy 时报错 21error deployer not found:git 问题出现的原因是：你更换了 theme，导致 git 提交的内容与服务器上完全不匹配。 解决办法：（在博客目录中执行） 1$ npm install hexo-deployer-git --save 然后再提交就可以了！ # 结语到这里，文章就结束啦。其他自定义的内容，请查看README.md就可以啦!(∩_∩)","link":"/create-the-blog-4/"},{"title":"Vue后台集成方案 之 基础模板","text":"#介绍vue-element-admin 是基于 Vue2.0，配合使用 Element UI 组件库的一个前端管理后台集成解决方案。它使用了最新的前端技术栈，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。 #建议项目的定位是后台集成方案，不适合当基础模板来进行二次开发。 集成方案: vue-element-admin 基础模板: vue-admin-template 桌面终端: electron-vue-admin # Build Setup 基本命令（总览）： 123456789101112131415161718# Clone projectgit clone https://github.com/PanJiaChen/vue-admin-template.git# Install dependenciesnpm install# 建议不要用 cnpm 安装有各种诡异的bug 可以通过如下操作解决npm速度慢的问题npm install --registry=https://registry.npm.taobao.org# Serve with hot reload at localhost:9528npm run dev# Build for production with minificationnpm run build# Build for production and view the bundle analyzer reportnpm run build --report 1.克隆项目到本地使用 cd 命令到自己想创建的文件夹路径下： 123$ cd 'CCcat/'$ git clone https://github.com/PanJiaChen/vue-admin-template.git 克隆项目到本地，会在本地新创建一个文件夹 vue-admin-template ： 1$ cd vue-admin-template/ 2.初始化项目 安装方式有 2 种 淘宝镜像安装（速度较快） 1$ npm install --registry=https://registry.npm.taobao.org 普通安装（速度一般） 1$ npm install 3.初始化 npm install 报错1npm ERR! cb() never called! 解决方法 输入以下命令，再试一遍： 123$ sudo npm cache clean -f # Clear your npm cache$ npm install --registry=https://registry.npm.taobao.org 图示： #本地运行项目1$ npm run dev # 开发模式 #打包项目1$ npm run build # 生产模式 # 结语Vue 后台集成方案 之 基础模板，教程到这就完成啦！(∩_∩)","link":"/create-vue-admin-template/"},{"title":"html5 postMessage解决跨域、跨窗口消息传递","text":"window.postMessage() 方法可以安全地实现跨源通信。 # 父子通信跨域1.子向父通信child.html 1234window.parent.postMessage({ msg:&quot;xxx&quot;},'*'); parent.html 1234567window.addEventListener('message',function(e){console.log(e.data);if(e.data.msg==='xxx'){ //一些自己的业务逻辑 }}); 2.父向子通信parent.html 123var myframe = document.getElementById('myframe');//获取iframemyframe.contentWindow.postMessage({data:'parent'},childDomain);//childDomain是子页面的源（协议+主机+端口号） child.html 1234window.addEventListener('message', function(e){ console.log(e.data.data);}) 注意： 1.子向父，子 postMessage,父监听 message; 2.父向子，父 postMessage,子监听 message; 3.测试发现，子向父 postMessage 的时候，源可以写为‘*’，父向子 postMessage 的时候，源需要写成子的源，(也就是子页面的协议+主机号+端口) # 测试代码部分* 向下 postMessage1234567891011var postMessage = function(id, msg, d) { /** * data 可以自定义为 object 或者 string * data 为 object */ var data = {}; data.identify = id; data.msg = msg; data.data = d; gameFrame.contentWindow.postMessage(data, &quot;*&quot;)}; * 向上 postMessage1234var chatReport = function(data) { /* data 为 string */ parent.window.postMessage(data, &quot;*&quot;)}; * 监听 Message（通用）123window.addEventListener('message', function(e){ console.log(e.data);});","link":"/h5-postMessage/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hello-world/"},{"title":"js设计模式-单例模式、策略模式","text":"问题场景:设计一个路由网关的解决方案, 解决根据不同嵌套路由在访问同一个域名的情况下, 跳转不同的应用程序。 例如: 1234567891011121314const url = 'http://url.com';- 指向a平台的url地址: `${url}/a/login` // a平台 登录页 `${url}/a/home` // a平台 主页 `${url}/a/user` // a平台 个人页 ...- 指向b平台的url地址: `${url}/b/login` // b平台 登录页 `${url}/b/home` // b平台 主页 `${url}/b/user` // b平台 个人页 ... 解决方法:方案一: 参考 JavaScript 设计模式, 使用 单例模式+策略模式 实现。使用单例模式实现网关的唯一性, 保证路由的准确性和统一性。在首次实例化单例模式的同时, 使用策略模式选择网关对应配置方案。 单例模式优点: 只需实例化一次, 减小内存使用压力 创建实例化后, 不允许被修改 策略模式优点: 同一个方法调用, 可通过策略判断选择 避免创建多个 if-else 代码示例:首先, 我们先创建一个通用的接口类SetSingle, 并暴露一个接口名 login() 1234// SetSingle.tsexport interface SetSingle { login(): void;} 然后创建不同的子类, 来实现通用接口类里的方法 123456789// ASingle.tsimport { SetSingle } from '@/../SetSingle';class ASingle implements SetSingle { public login(): void { console.log('ASingle login'); }}export default ASingle; 123456789// BSingle.tsimport { SetSingle } from '@/../SetSingle';class BSingle implements SetSingle { public login(): void { console.log('BSingle login'); }}export default BSingle; 我们再创建一个最关键的, 单例模式父类, 实例化方法getInstance(), 如果已经实例化方法一次, 则返回自身。 12345678910111213141516171819202122232425262728293031323334353637383940// Context.tsimport { SetSingle } from '@/../SetSingle';class Context { /** * 使用 static 定义静态方法, 以静态方法或者枚举返回实例 * 使用 static 在堆内存开辟内存空间 * 在堆内存中实例化SetSingle里面的各个参数 * static 把对象指向堆内存空间 */ private static instance: Context; private single: SetSingle = null; // 在构造函数里使用 this, 指向自身。 // 一般适用于构造函数内需要传参时使用 constructor() { // Context.instance = this } public static getInstance() { if (!Context.instance) { Context.instance = new Context(); } return Context.instance; } // 子类构造类 public SetSingle(single: SetSingle) { if (this.single == null) { this.single = single; } } // 函数类 public login() { this.single.login(); }}export default Context; 实例化与使用 12345678910111213141516const context = Context.getInstance();const path = pathToRegexp('/a/:path(.*)').exec(to.path + '');if( path !== null ){ context.SetSingle(new ASingle()); context.login(); console.log(context.login()) // ASingle login } else { context.SetSingle(new BSingle()); context.login(); console.log(context.login()) // BSingle login }","link":"/js-design-singleton/"},{"title":"使用socket.io和node.js搭建websocket应用","text":"# 介绍使用流行的 Web 应用程序堆栈（如 LAMP（PHP））编写聊天应用程序一直非常困难。它涉及轮询服务器以进行更改，跟踪时间戳，并且它比它应该慢得多。 传统上，套接字是大多数实时聊天系统所构建的解决方案，在客户端和服务器之间提供双向通信通道。 这意味着服务器可以将消息推送到客户端。每当您编写聊天消息时，其想法是服务器将获取它并将其推送到所有其他连接的客户端。 参考官方文档socket.io：https://socket.io/get-started/chat/下面是我个人理解的简易版： # Web 框架1.新建文件夹新建一个文件夹 airconnect（文件夹名称自定义）。 终端运行： 1$ mkdir airconnect 2.新建文件在 airconnect 文件夹下，初始化文件 package.json。 终端运行： 12$ cd airconnect$ npm init -y 3.安装 socket.io 模块。 在 airconnect 文件夹目录路径下 终端运行： 1$ npm install --save socket.io 截图： 没有报错就是安装成功！（ WARN 的原因是有一些配置没添加，无所谓，我们现在只做简易版的。 ） 4.在 airconnect 文件夹下，新建一个文件 app.js。 app.js 文件：https://gitlab.com/snippets/1795935 app.js 文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 引入需要的模块：http和socket.io// 定义端口号：8080var http = require('http'), io = require('socket.io'), port = process.env.PORT || 8080;//创建 servervar server = http.createServer(function (req, res) { // Send HTML headers and message res.writeHead(200, { 'Content-Type': 'text/html' }); res.end('# Hello Socket Lover!');});// listener// 监听 端口(8080) 事件server.listen(port, function () { console.log('listening on \\*:' + port);});// 创建 socketvar socket = io.listen(server);// 添加连接监听socket.on('connection', function (client) { // 连接成功则执行下面的监听 client.on('message', function (event) { // Received message from client! console.log('message', event); socket.emit(&quot;message&quot;, event); }); client.on('data', function (event) { // Received data from client! console.log('data', event); socket.emit(&quot;data&quot;, event); }); // 断开连接callback client.on('disconnect', function () { console.log('Server has disconnected'); });}); 现在的 airconnect 文件夹内容截图： 关于截图里的 page1.html、page2.html 文件，我们后续讲到。 5.运行 我们使http服务器侦听端口8080，这时在终端运行命令： 1$ node app.js 截图： 如果您将浏览器指向 http://localhost:8080： 截图： 对应的输入 log: 输出正确的 log，就是运行成功！ # 提供 HTML page1.html 文件： https://jsbin.com/zaxida/1/edit?html,console,output page2.html 文件： https://jsbin.com/meyopov/2/edit?html,console,output # 实现通讯 视频演示地址： https://pan.baidu.com/s/1mKQu6P10lT331CvkJGWuLg 说明： 第一步：打开终端，在 airconnect 文件夹目录路径下，运行命令： node app.js 1$ node app.js 检查：在浏览器标签页中，打开 http://localhost:8080，查看正确的 log 信息是否显示。 第二步：在浏览器标签页中，分别打开 page1.html 和 page2.html 文件。 可以手动拖拽到浏览器标签页中 或者鼠标双击本地文件，将自动在浏览器标签页中打开 第三步：在 page1.html 输入框中输入任意文本，测试 page2.html 是否能正确接收到 page1 发送的信息。 设置 服务器地址 和 端口号 8080 socket = io.connect(‘http://localhost:8080') 接收 message 字段名发送的消息 socket.on(‘message’, function (json) {}) 接收 data 字段名发送的消息 socket.on(‘data’, function (json) {}) 端口号 8080，可以自定义。message 和 data 字段名，可以自定义。 # 结语以上就完成了使用 socket.io 和 node.js 搭建 websocket 应用。","link":"/use-websocket-chat/"},{"title":"vue从0到1：vue + webpack + element-ui + axios 项目搭建","text":"# 介绍Vue.js 是一款极简的 mvvm 框架。用一个词来形容它，就是 “轻·巧” 。如果我们用一句话来描述它，它能够集众多优秀逐流的前端框架之大成，但同时保持简单易用。 # 全局安装 vue-cli 1234$ npm install -g vue #全局安装vue$ npm install -g vue-cli #全局安装vue-cli # 全局安装 webpack12$ npm install -g webpack #全局安装webpack # 初始化项目1.创建项目文件夹1234$ vue init webpack 'vue-project' #初始化项目，项目名称：vue-project$ npm install webpack --save-dev #项目内安装webpack 注：–save 和 –save-dev 是将 安装好的包 保存在 package.json 中，可以省掉你手动修改 package.json 文件的步骤。 详细说明： –save : 自动把模块和版本号添加到 dependencies 部分。–save-dev : 自动把模块和版本号添加到 devdependencies 部分。 form https://docs.npmjs.com/cli/install 通过这些命令，我们会得到一个新的 package.json。然后再做一个试验就懂得了区别：删除 node_modules 目录，然后执行 npm install –production，可以看到，npm 只帮我们自动安装 package.json 中 dependencies 部分的模块；如果执行 npm install ，则 package.json 中指定的 dependencies 和 devDependencies 都会被自动安装进来。 2.在本地运行项目1$ npm run dev #运行项目 根据终端提示，在浏览器打开 http://localhost:8080 1Your application is running here: http://localhost:8080 # 节点图示 图示里是先创建了项目文件夹，最终效果跟上面的步骤一样。 从新建项目起： # 节点说明（vue + webpack 项目）执行 npm run dev 成功后，打开浏览器 http://localhost:8080 并且没报错的情况下， vue + webpack 项目搭建 就完成了，按需进行以下安装。(∩_∩) # 使用 Element-UI 前，需安装、修改的配置1.安装loader模块123456$ npm install style-loader -D$ npm install css-loader -D$ npm install file-loader -D 图示： # 安装 Element-UI1.安装element-ui模块12$ npm install element-ui --save 2.引入 Element，前面已经全局安装了 element-ui，只需要在 Vue 项目中引入即可打开项目：src/main.js,添加下面三条 1234import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'Vue.use(ElementUI) 图示： 3.结束 🔚到这一步，element-ui 模块就安装完成了！😄😄然后在.vue 文件里就直接使用了。 # 节点说明（vue + webpack + element-ui 项目）执行到这，vue + webpack + element-ui 项目搭建 就完成了，按需进行以下安装。(∩_∩) # 安装 Axios12$ npm install axios # 安装 Vue-axios12$ npm install --save axios vue-axios # 使用 Axios 小案例1.新建文件新建文件 RouterPage.vue，位置放在 src &gt; components 文件夹下。 2.修改默认的路由文件文件位置在src &gt; router &gt; index.js。 3.运行运行 npm run dev 成功后，打开浏览器 http://localhost:8080，测试页面是否修改正确。 终端： 浏览器：（显示正确） 在终端使用快捷键 control + c，来终止运行。 4.新建必备文件 新建文件夹 utils ，位置放在 src 文件夹下。 新建文件 request.js ，位置放在 src &gt; utils 文件夹下。 request.js 文件内容： 123456789101112131415161718192021222324252627282930313233343536373839import axios from 'axios'import { Message } from 'element-ui'// create an axios instanceaxios.defaults.withCredentials = falseconst service = axios.create({ baseURL: 'https://你的请求域名地址.com', // api 的 base_url timeout: 50000 // request timeout})// request interceptorservice.interceptors.request.use( config =&gt; // Do something before request is sent config, (error) =&gt; { // Do something with request error console.log(error) // for debug Promise.reject(error) })// response interceptorservice.interceptors.response.use( response =&gt; response, (error) =&gt; { console.log(`err${error}`) // for debug Message({ showClose: true, message: error.message + '，请重新刷新页面试试~', type: 'error', duration: 5 * 1000 }) return Promise.reject(error) })export default service 新建文件夹 api ，位置放在 src 文件夹下。 新建文件 routerPage.js ，位置放在 src &gt; api 文件夹下。 routerPage.js 文件内容： 示例只用了 HTTP GET 测试，我这里把 http post 写法注释掉了。 12345678910111213141516171819202122import request from '@/utils/request'# http get 写法export function msgCheck (query) { return request({ url: '/api/msgTxtCheck', method: 'get', params: query })}# http post 写法# export function msgShow (name, key) {# var params = new URLSearchParams()# params.append('name', name) #参数# params.append('key', key) #参数# return request({# url: '/api/msgTxtShow',# method: 'post',# data: params# })# } 5.修改文件修改文件 RouterPage.vue ，增加测试按钮。 RouterPage.vue 文件内容： 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class='app-container'&gt; &lt;div&gt;{{ msg }}&lt;/div&gt; &lt;el-button type='primary' icon='el-icon-search' @click='getMsgCheck'&gt;{{ btnName }}&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { msgCheck } from '../api/routerPage'export default { name: 'RouterPage', data () { return { msg: '搜芽', btnName: '我是按钮~' } }, methods: { getMsgCheck () { var data = { boos_name: this.msg } msgCheck(data).then(response =&gt; { console.log(response) }) } }}&lt;/script&gt;&lt;!-- Add 'scoped' attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; 执行 npm run dev成功后，打开浏览器 http://localhost:8080，开始测试。 图示总结： # 常用 Vue 终端命令1234$ npm run dev #本地运行项目$ npm run build #发布项目到线上 # 结语 vue + webpack + element-ui + axios 项目搭建，完成啦！以上，就完成了一个正式 Vue 项目的基础搭建。(∩_∩)","link":"/vue-project/"},{"title":"vue 前端优化小技巧","text":"前端优化小技巧 1.history 模式vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问不存在的路由, 就会返回 404，这就不好看了。 所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 后端配置例子: Apache 12345678&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase / RewriteRule ^index\\.html$ - [L] RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule . /index.html [L]&lt;/IfModule&gt; Nginx 1234location / { #设置所有找不到的页面, 跳转到index.html页面 tryfiles $uri $uri/ /index.html;} 2.每次加载首页, 页面都是最新的Nginx 123456location / { #设置某个文件不缓存读取本地，永远走200，拿到最新的 if ($requestfilename ~* .*\\.(?:htm|html)$) { addheader Cache-Control &quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;; }} 3.Nginx配置前端接口转发1234567location /api/ { proxypass http://ip:3000/; #这里的转发地址记得改成项目对应的哦 proxysetheader Host $httphost; proxysetheader X-Real-IP $remoteaddr; proxysetheader REMOTE-HOST $remoteaddr; proxysetheader X-Forwarded-For $proxyaddxforwarded_for;}","link":"/vue-tips/"},{"title":"Vue隐藏技能--运行时渲染","text":"本地编译与运行时编译用户想通过编写template + js + css的方式实现运行时渲染页面，那肯定是不能本地编译的（此处的编译指将vue文件编译为js资源文件），即不能把用户写的代码像编译源码一样打包成静态资源文件。 这些代码只能原样持久化到数据库，每次打开页面再恢复回来，实时编译。毕竟不是纯js文件，是不能直接运行的，它需要一个运行时环境，运行时编译，这个环境就是 vue的运行时 + 编译器。 技术干货 按官方的介绍，通过script标签引入vue就可以渐进式开发了，也就具备了运行时+编译器, 如下: 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;{{message}}&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 但通过vue单文件+webpack编译的方式，再引入一个vue就多余了，通过CLI也是可以的，只需要在vue.config.js中打开runtimeCompiler开关就行了，详细看文档。 1234// vue.config.jsmodule.exports = { runtimeCompiler: true} 此时我们就有了一个运行时编译环境。 动态HTML模板渲染示例:12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;component v-bind:is=&quot;processedHtml&quot; @clickMe=&quot;clickMe&quot;&gt;&lt;/component&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'ShowHtml', components: { }, data: () =&gt; ({ html: '&lt;p&gt;我是段落&lt;/p&gt; [BuyHere]' }), methods: { clickMe() { console.log('ok'); alert('clickMe ok') } }, computed: { processedHtml() { const html = this.html.replace('[BuyHere]','&lt;el-button type=&quot;primary&quot; plain @click=&quot;clickMe&quot;&gt;点我&lt;/el-button&gt;'); return { template: '&lt;div&gt;' + html + '&lt;/div&gt;', props: { label: { type: null, default: () =&gt; { return this.label } } }, methods: { clickMe() { this.$emit( 'clickMe') } } } } }}&lt;/script&gt; 完结。","link":"/vue-tips2/"}],"tags":[{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"promise","slug":"promise","link":"/tags/promise/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"gitHub","slug":"gitHub","link":"/tags/gitHub/"},{"name":"github-pages","slug":"github-pages","link":"/tags/github-pages/"},{"name":"theme","slug":"theme","link":"/tags/theme/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue-admin-template","slug":"vue-admin-template","link":"/tags/vue-admin-template/"},{"name":"Vue后台集成方案(基础模板)","slug":"Vue后台集成方案-基础模板","link":"/tags/Vue%E5%90%8E%E5%8F%B0%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88-%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"},{"name":"跨域通讯","slug":"跨域通讯","link":"/tags/%E8%B7%A8%E5%9F%9F%E9%80%9A%E8%AE%AF/"},{"name":"postMessage","slug":"postMessage","link":"/tags/postMessage/"},{"name":"hello-world","slug":"hello-world","link":"/tags/hello-world/"},{"name":"javascript-design-singleton","slug":"javascript-design-singleton","link":"/tags/javascript-design-singleton/"},{"name":"websocket","slug":"websocket","link":"/tags/websocket/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"element-ui","slug":"element-ui","link":"/tags/element-ui/"},{"name":"前端性能优化","slug":"前端性能优化","link":"/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","link":"/categories/%E5%90%8E%E7%AB%AF/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"}]}